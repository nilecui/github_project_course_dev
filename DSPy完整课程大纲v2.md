# DSPyå®Œæ•´è¯¾ç¨‹å¤§çº² v2.0
## ç¼–ç¨‹å¼AIç³»ç»Ÿå¼€å‘å®æˆ˜è¯¾ç¨‹

---

## ğŸ“– è¯¾ç¨‹ç®€ä»‹

### è¯¾ç¨‹æ¦‚è¿°
**è¯¾ç¨‹åç§°ï¼š** DSPy - å£°æ˜å¼è‡ªæ”¹è¿›AIç³»ç»Ÿå¼€å‘å®æˆ˜
**è¯¾ç¨‹ç‰ˆæœ¬ï¼š** 2.0
**æŠ€æœ¯ç‰ˆæœ¬ï¼š** DSPy 3.0.4
**æ›´æ–°æ—¥æœŸï¼š** 2024å¹´11æœˆ

### è¯¾ç¨‹ç‰¹è‰²
- ğŸ¯ **ç¼–ç¨‹æ€ç»´**ï¼šç”¨ç¼–ç¨‹è€Œéæç¤ºçš„æ–¹å¼æ„å»ºAIç³»ç»Ÿ
- ğŸ”§ **æ¨¡å—åŒ–è®¾è®¡**ï¼šå­¦ä¹ æ„å»ºå¯å¤ç”¨ã€å¯ç»„åˆçš„AIç»„ä»¶
- âš¡ **è‡ªåŠ¨ä¼˜åŒ–**ï¼šæŒæ¡æœ€å…ˆè¿›çš„promptå’Œæƒé‡ä¼˜åŒ–ç®—æ³•
- ğŸš€ **ç”Ÿäº§å°±ç»ª**ï¼šä»åŸå‹åˆ°ç”Ÿäº§éƒ¨ç½²çš„å®Œæ•´æµç¨‹
- ğŸ’¡ **å®æˆ˜å¯¼å‘**ï¼šæ¯ä¸ªæ¨¡å—é…å¥—çœŸå®é¡¹ç›®æ¡ˆä¾‹

### é€‚ç”¨äººç¾¤
- âœ… Pythonå¼€å‘è€…ï¼ˆæœ‰1å¹´ä»¥ä¸Šå¼€å‘ç»éªŒï¼‰
- âœ… AI/MLå·¥ç¨‹å¸ˆï¼ˆå¸Œæœ›æå‡AIç³»ç»Ÿå¼€å‘èƒ½åŠ›ï¼‰
- âœ… äº§å“ç»ç†ï¼ˆéœ€è¦ç†è§£AIç³»ç»Ÿæ¶æ„ï¼‰
- âœ… æŠ€æœ¯è´Ÿè´£äººï¼ˆè§„åˆ’AIäº§å“æŠ€æœ¯è·¯çº¿ï¼‰
- âœ… ç ”ç©¶äººå‘˜ï¼ˆæ¢ç´¢å‰æ²¿AIæŠ€æœ¯ï¼‰

### å‰ç½®è¦æ±‚
**å¿…å¤‡æŠ€èƒ½ï¼š**
- Python 3.10+ ç¼–ç¨‹åŸºç¡€
- åŸºæœ¬çš„å‘½ä»¤è¡Œæ“ä½œ
- Gitç‰ˆæœ¬æ§åˆ¶
- åŸºç¡€çš„æœºå™¨å­¦ä¹ æ¦‚å¿µ

**æ¨èæŠ€èƒ½ï¼š**
- é¢å‘å¯¹è±¡ç¼–ç¨‹ç»éªŒ
- Web APIå¼€å‘ç»éªŒ
- æ•°æ®å¤„ç†ç»éªŒï¼ˆpandasç­‰ï¼‰
- äº†è§£Transformerå’ŒLLMåŸºç¡€

### å­¦ä¹ æˆæœ
å®Œæˆè¯¾ç¨‹åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
1. âœ… è®¾è®¡å’Œå®ç°å¤æ‚çš„AIç³»ç»Ÿæ¶æ„
2. âœ… æ„å»ºç”Ÿäº§çº§RAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰ç³»ç»Ÿ
3. âœ… å¼€å‘åŠŸèƒ½å®Œæ•´çš„AIæ™ºèƒ½ä½“
4. âœ… ä½¿ç”¨è‡ªåŠ¨ä¼˜åŒ–ç®—æ³•æå‡ç³»ç»Ÿæ€§èƒ½
5. âœ… éƒ¨ç½²å’Œç»´æŠ¤å¤§è§„æ¨¡AIåº”ç”¨
6. âœ… è´¡çŒ®å¼€æºé¡¹ç›®å¹¶å‚ä¸ç¤¾åŒº

### è¯¾ç¨‹æ—¶é•¿
- **æ€»å­¦ä¹ æ—¶é•¿ï¼š** 12å‘¨ï¼ˆ84å¤©ï¼‰
- **æ¯å‘¨å­¦ä¹ æ—¶é—´ï¼š** 10-15å°æ—¶
- **æ€»å­¦æ—¶ï¼š** 120-180å°æ—¶
- **ç†è®ºä¸å®è·µæ¯”ä¾‹ï¼š** 3:7

---

## ğŸ—ºï¸ è¯¾ç¨‹ç»“æ„

### å››å¤§å­¦ä¹ é˜¶æ®µ

```
é˜¶æ®µä¸€ï¼šåŸºç¡€å…¥é—¨ï¼ˆç¬¬1-3å‘¨ï¼‰
    â”œâ”€â”€ æ¨¡å—1ï¼šDSPyå…¥é—¨ä¸ç¯å¢ƒæ­å»º
    â”œâ”€â”€ æ¨¡å—2ï¼šç­¾åç³»ç»Ÿä¸æ•°æ®æµ
    â”œâ”€â”€ æ¨¡å—3ï¼šåŸºç¡€é¢„æµ‹æ¨¡å—
    â””â”€â”€ æ¨¡å—4ï¼šç®€å•ä»»åŠ¡å®æˆ˜

é˜¶æ®µäºŒï¼šè¿›é˜¶å¼€å‘ï¼ˆç¬¬4-6å‘¨ï¼‰
    â”œâ”€â”€ æ¨¡å—5ï¼šModuleç±»ä¸ç»„åˆè®¾è®¡
    â”œâ”€â”€ æ¨¡å—6ï¼šæ£€ç´¢å¢å¼ºç”Ÿæˆ(RAG)
    â”œâ”€â”€ æ¨¡å—7ï¼šæ™ºèƒ½ä½“å¼€å‘
    â””â”€â”€ æ¨¡å—8ï¼šå¤æ‚æ¨ç†ç³»ç»Ÿ

é˜¶æ®µä¸‰ï¼šä¼˜åŒ–éƒ¨ç½²ï¼ˆç¬¬7-9å‘¨ï¼‰
    â”œâ”€â”€ æ¨¡å—9ï¼šè‡ªåŠ¨ä¼˜åŒ–ç®—æ³•
    â”œâ”€â”€ æ¨¡å—10ï¼šè¯„ä¼°ä¸è°ƒè¯•
    â”œâ”€â”€ æ¨¡å—11ï¼šç”Ÿäº§éƒ¨ç½²æœ€ä½³å®è·µ
    â””â”€â”€ æ¨¡å—12ï¼šæ€§èƒ½ç›‘æ§ä¸ç»´æŠ¤

é˜¶æ®µå››ï¼šé«˜çº§ä¸“é¢˜ï¼ˆç¬¬10-12å‘¨ï¼‰
    â”œâ”€â”€ æ¨¡å—13ï¼šè‡ªå®šä¹‰ç»„ä»¶å¼€å‘
    â”œâ”€â”€ æ¨¡å—14ï¼šå¤šæ¨¡æ€ä¸å‰æ²¿åº”ç”¨
    â”œâ”€â”€ æ¨¡å—15ï¼šæ¯•ä¸šé¡¹ç›®ä¸ç­”è¾©
    â””â”€â”€ èŒä¸šå‘å±•ä¸ç¤¾åŒºè´¡çŒ®
```

---

## ğŸ“š è¯¦ç»†è¯¾ç¨‹å†…å®¹

### ğŸŒ± é˜¶æ®µä¸€ï¼šåŸºç¡€å…¥é—¨ï¼ˆç¬¬1-3å‘¨ï¼‰

#### æ¨¡å—1ï¼šDSPyå…¥é—¨ä¸ç¯å¢ƒæ­å»ºï¼ˆç¬¬1å‘¨ï¼Œ10å°æ—¶ï¼‰

**å­¦ä¹ ç›®æ ‡**
- ç†è§£DSPyçš„è®¾è®¡å“²å­¦å’Œæ ¸å¿ƒä¼˜åŠ¿
- æŒæ¡å®Œæ•´çš„å¼€å‘ç¯å¢ƒæ­å»º
- äº†è§£DSPyç”Ÿæ€ç³»ç»Ÿå’Œåº”ç”¨åœºæ™¯
- è¿è¡Œç¬¬ä¸€ä¸ªDSPyç¨‹åº

**æ ¸å¿ƒå†…å®¹**

**1.1 DSPyç®€ä»‹ï¼ˆ2å°æ—¶ï¼‰**
- DSPyæ˜¯ä»€ä¹ˆï¼šDeclarative Self-improving Python
- ä¸ºä»€ä¹ˆé€‰æ‹©ç¼–ç¨‹è€Œéæç¤º
  - ä¼ ç»Ÿprompt engineeringçš„å±€é™æ€§
  - ç¼–ç¨‹å¼å¼€å‘çš„ä¼˜åŠ¿
  - å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§
- DSPy vs LangChain vs Semantic Kernelå¯¹æ¯”
- æˆåŠŸæ¡ˆä¾‹å±•ç¤º
  - Stanford NLPçš„ç ”ç©¶åº”ç”¨
  - ä¼ä¸šçº§ç”Ÿäº§æ¡ˆä¾‹
  - å¼€æºç¤¾åŒºé¡¹ç›®

**1.2 æ ¸å¿ƒæ¦‚å¿µæ¦‚è§ˆï¼ˆ2å°æ—¶ï¼‰**
- **Signaturesï¼ˆç­¾åï¼‰**ï¼šä»»åŠ¡çš„è¾“å…¥è¾“å‡ºè§„èŒƒ
- **Modulesï¼ˆæ¨¡å—ï¼‰**ï¼šå¯ç»„åˆçš„AIç»„ä»¶
- **Telepromptersï¼ˆä¼˜åŒ–å™¨ï¼‰**ï¼šè‡ªåŠ¨ä¼˜åŒ–ç®—æ³•
- **Predictorsï¼ˆé¢„æµ‹å™¨ï¼‰**ï¼šæ¨ç†æ‰§è¡Œå™¨
- **Retrieversï¼ˆæ£€ç´¢å™¨ï¼‰**ï¼šçŸ¥è¯†è·å–ç»„ä»¶
- æ•°æ®æµå’Œæ‰§è¡Œæµç¨‹

**1.3 ç¯å¢ƒæ­å»ºå®æˆ˜ï¼ˆ3å°æ—¶ï¼‰**
```bash
# åˆ›å»ºPythonè™šæ‹Ÿç¯å¢ƒ
python -m venv dspy_env
source dspy_env/bin/activate  # Windows: dspy_env\Scripts\activate

# å®‰è£…DSPy
pip install dspy

# å®‰è£…å¼€å‘ä¾èµ–
pip install jupyter notebook ipython
pip install python-dotenv  # ç”¨äºç®¡ç†APIå¯†é’¥

# éªŒè¯å®‰è£…
python -c "import dspy; print(dspy.__version__)"
```

**APIå¯†é’¥é…ç½®**
```python
# .env æ–‡ä»¶é…ç½®
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=...
```

**å¼€å‘å·¥å…·é…ç½®**
- VSCode + Pythonæ‰©å±•
- Jupyter Notebooké…ç½®
- Gitä»“åº“åˆå§‹åŒ–

**1.4 ç¬¬ä¸€ä¸ªDSPyç¨‹åºï¼ˆ3å°æ—¶ï¼‰**
```python
import dspy
from dspy import OpenAI

# 1. é…ç½®è¯­è¨€æ¨¡å‹
lm = OpenAI(model="gpt-3.5-turbo", max_tokens=250)
dspy.settings.configure(lm=lm)

# 2. å®šä¹‰ä»»åŠ¡ç­¾å
class QuestionAnswering(dspy.Signature):
    """æ ¹æ®é—®é¢˜ç”Ÿæˆå‡†ç¡®çš„ç­”æ¡ˆ"""
    question = dspy.InputField(desc="ç”¨æˆ·æå‡ºçš„é—®é¢˜")
    answer = dspy.OutputField(desc="è¯¦ç»†çš„ç­”æ¡ˆ")

# 3. åˆ›å»ºé¢„æµ‹å™¨
qa_predictor = dspy.Predict(QuestionAnswering)

# 4. æ‰§è¡Œé¢„æµ‹
question = "ä»€ä¹ˆæ˜¯DSPyï¼Ÿå®ƒæœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ"
result = qa_predictor(question=question)

print(f"é—®é¢˜ï¼š{question}")
print(f"ç­”æ¡ˆï¼š{result.answer}")
```

**å¯¹æ¯”å®éªŒï¼šä¼ ç»ŸPrompt vs DSPy**
```python
# ä¼ ç»Ÿæ–¹å¼
prompt = f"è¯·å›ç­”ä»¥ä¸‹é—®é¢˜ï¼š{question}\nç­”æ¡ˆï¼š"
# éœ€è¦æ‰‹åŠ¨å¤„ç†promptæ ¼å¼ã€è§£æå“åº”ç­‰

# DSPyæ–¹å¼
result = qa_predictor(question=question)
# è‡ªåŠ¨å¤„ç†æ ¼å¼åŒ–ã€ç±»å‹éªŒè¯ã€é”™è¯¯å¤„ç†
```

**å®è·µä»»åŠ¡**
- [ ] å®Œæˆå¼€å‘ç¯å¢ƒæ­å»º
- [ ] é…ç½®è‡³å°‘2ç§LLMï¼ˆOpenAI, Anthropicç­‰ï¼‰
- [ ] è¿è¡Œå¹¶ç†è§£ç¬¬ä¸€ä¸ªç¨‹åº
- [ ] ä¿®æ”¹ç­¾åï¼Œæ·»åŠ æ–°çš„è¾“å…¥/è¾“å‡ºå­—æ®µ
- [ ] å¯¹æ¯”3ç§ä¸åŒæ¨¡å‹çš„è¾“å‡ºè´¨é‡
- [ ] æ’°å†™å­¦ä¹ ç¬”è®°ï¼ˆè‡³å°‘500å­—ï¼‰

**è¯„ä¼°æ ‡å‡†**
- ç¯å¢ƒæ­å»ºæˆåŠŸ âœ“
- ç¨‹åºè¿è¡Œæ— è¯¯ âœ“
- ç†è§£æ ¸å¿ƒæ¦‚å¿µ âœ“
- å®Œæˆå¯¹æ¯”å®éªŒ âœ“

---

#### æ¨¡å—2ï¼šç­¾åç³»ç»Ÿä¸æ•°æ®æµï¼ˆç¬¬1-2å‘¨ï¼Œ12å°æ—¶ï¼‰

**å­¦ä¹ ç›®æ ‡**
- æ·±å…¥ç†è§£Signatureç³»ç»Ÿçš„è®¾è®¡ç†å¿µ
- æŒæ¡å¤æ‚ä»»åŠ¡è§„èŒƒçš„å®šä¹‰æ–¹æ³•
- å­¦ä¼šæ•°æ®æµç®¡ç†å’ŒéªŒè¯
- å®ç°ç±»å‹å®‰å…¨çš„AIç¨‹åº

**æ ¸å¿ƒå†…å®¹**

**2.1 ç­¾åç³»ç»Ÿæ·±åº¦è§£æï¼ˆ4å°æ—¶ï¼‰**

**åŸºç¡€ç­¾åå®šä¹‰**
```python
import dspy
from pydantic import BaseModel, Field
from typing import List, Optional

# ç®€å•ç­¾å
class BasicQA(dspy.Signature):
    question = dspy.InputField()
    answer = dspy.OutputField()

# å¸¦æè¿°çš„ç­¾å
class DetailedQA(dspy.Signature):
    """ä¸“ä¸šé—®ç­”ç³»ç»Ÿç­¾å"""
    context = dspy.InputField(desc="ç›¸å…³èƒŒæ™¯ä¿¡æ¯")
    question = dspy.InputField(desc="ç”¨æˆ·é—®é¢˜")
    answer = dspy.OutputField(desc="åŸºäºcontextçš„å‡†ç¡®ç­”æ¡ˆ")
    confidence = dspy.OutputField(desc="ç­”æ¡ˆç½®ä¿¡åº¦ï¼Œ0-1ä¹‹é—´çš„æµ®ç‚¹æ•°")
```

**å¤æ‚ç­¾åè®¾è®¡**
```python
class MultiStepReasoning(dspy.Signature):
    """å¤šæ­¥æ¨ç†ä»»åŠ¡ç­¾å"""
    # è¾“å…¥å­—æ®µ
    problem = dspy.InputField(desc="éœ€è¦è§£å†³çš„é—®é¢˜")
    constraints = dspy.InputField(desc="çº¦æŸæ¡ä»¶åˆ—è¡¨")

    # è¾“å‡ºå­—æ®µ
    reasoning_steps = dspy.OutputField(desc="æ¨ç†æ­¥éª¤çš„åˆ—è¡¨")
    final_answer = dspy.OutputField(desc="æœ€ç»ˆç­”æ¡ˆ")
    alternative_solutions = dspy.OutputField(desc="å¤‡é€‰æ–¹æ¡ˆ")
    confidence_score = dspy.OutputField(desc="ç½®ä¿¡åº¦è¯„åˆ†")

class CodeGeneration(dspy.Signature):
    """ä»£ç ç”Ÿæˆç­¾å"""
    requirements = dspy.InputField(desc="åŠŸèƒ½éœ€æ±‚æè¿°")
    language = dspy.InputField(desc="ç¼–ç¨‹è¯­è¨€")
    style_guide = dspy.InputField(desc="ä»£ç é£æ ¼æŒ‡å—", default="PEP8")

    code = dspy.OutputField(desc="ç”Ÿæˆçš„ä»£ç ")
    explanation = dspy.OutputField(desc="ä»£ç è¯´æ˜")
    test_cases = dspy.OutputField(desc="æµ‹è¯•ç”¨ä¾‹")
```

**2.2 æ•°æ®æµç®¡ç†ï¼ˆ4å°æ—¶ï¼‰**

**Exampleç±»ä½¿ç”¨**
```python
from dspy import Example

# åˆ›å»ºè®­ç»ƒæ ·æœ¬
train_examples = [
    Example(
        question="Pythonä¸­å¦‚ä½•åˆ›å»ºåˆ—è¡¨ï¼Ÿ",
        answer="ä½¿ç”¨æ–¹æ‹¬å·[]æˆ–list()å‡½æ•°",
        category="åŸºç¡€",
        difficulty="ç®€å•"
    ).with_inputs("question"),  # æ ‡è®°è¾“å…¥å­—æ®µ

    Example(
        question="è§£é‡Šè£…é¥°å™¨çš„å·¥ä½œåŸç†",
        answer="è£…é¥°å™¨æ˜¯ä¸€ä¸ªæ¥å—å‡½æ•°å¹¶è¿”å›æ–°å‡½æ•°çš„é«˜é˜¶å‡½æ•°...",
        category="è¿›é˜¶",
        difficulty="ä¸­ç­‰"
    ).with_inputs("question")
]

# æ•°æ®é›†åˆ†å‰²
from sklearn.model_selection import train_test_split
trainset, devset = train_test_split(
    train_examples,
    test_size=0.2,
    random_state=42
)
```

**æ•°æ®éªŒè¯å’Œæ¸…æ´—**
```python
def validate_example(example: Example) -> bool:
    """éªŒè¯ç¤ºä¾‹æ•°æ®çš„å®Œæ•´æ€§"""
    required_fields = ["question", "answer"]

    # æ£€æŸ¥å¿…éœ€å­—æ®µ
    for field in required_fields:
        if not hasattr(example, field) or not getattr(example, field):
            return False

    # æ£€æŸ¥æ•°æ®è´¨é‡
    if len(example.question) < 5:
        return False
    if len(example.answer) < 10:
        return False

    return True

# æ¸…æ´—æ•°æ®é›†
clean_examples = [ex for ex in train_examples if validate_example(ex)]
```

**2.3 ç±»å‹ç³»ç»Ÿä¸Pydanticé›†æˆï¼ˆ4å°æ—¶ï¼‰**

**ä½¿ç”¨Pydanticå®šä¹‰å¤æ‚ç±»å‹**
```python
from pydantic import BaseModel, Field, validator
from typing import List, Optional
from enum import Enum

class DifficultyLevel(str, Enum):
    EASY = "ç®€å•"
    MEDIUM = "ä¸­ç­‰"
    HARD = "å›°éš¾"

class QuestionMetadata(BaseModel):
    difficulty: DifficultyLevel
    topics: List[str]
    estimated_time: int = Field(..., ge=1, le=120, description="é¢„è®¡è§£ç­”æ—¶é—´(åˆ†é’Ÿ)")

    @validator('topics')
    def validate_topics(cls, v):
        if len(v) == 0:
            raise ValueError("è‡³å°‘éœ€è¦ä¸€ä¸ªä¸»é¢˜æ ‡ç­¾")
        return v

class StructuredQA(dspy.Signature):
    """ç»“æ„åŒ–é—®ç­”ç­¾å"""
    question = dspy.InputField()
    metadata = dspy.InputField()  # QuestionMetadataç±»å‹

    answer = dspy.OutputField()
    confidence = dspy.OutputField()
    sources = dspy.OutputField()  # List[str]ç±»å‹
```

**å®è·µä»»åŠ¡**
- [ ] è®¾è®¡5ç§ä¸åŒå¤æ‚åº¦çš„ä»»åŠ¡ç­¾å
- [ ] å®ç°å®Œæ•´çš„æ•°æ®éªŒè¯ç®¡é“
- [ ] ä½¿ç”¨Pydanticå®šä¹‰å¤æ‚æ•°æ®ç±»å‹
- [ ] åˆ›å»ºå¯å¤ç”¨çš„ç­¾åæ¨¡æ¿åº“
- [ ] å¤„ç†è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯

**è¯„ä¼°æ ‡å‡†**
- ç­¾åè®¾è®¡åˆç†æ€§ âœ“
- æ•°æ®æµå¤„ç†æ­£ç¡®æ€§ âœ“
- ç±»å‹å®‰å…¨å®ç° âœ“
- é”™è¯¯å¤„ç†å®Œå–„æ€§ âœ“

---

#### æ¨¡å—3ï¼šåŸºç¡€é¢„æµ‹æ¨¡å—ï¼ˆç¬¬2å‘¨ï¼Œ12å°æ—¶ï¼‰

**å­¦ä¹ ç›®æ ‡**
- æŒæ¡æ‰€æœ‰åŸºç¡€é¢„æµ‹æ¨¡å—çš„ä½¿ç”¨
- ç†è§£ä¸åŒæ¨ç†æ¨¡å¼çš„é€‚ç”¨åœºæ™¯
- å­¦ä¼šé€‰æ‹©å’Œç»„åˆé¢„æµ‹æ¨¡å—
- ä¼˜åŒ–æ¨ç†è´¨é‡å’Œæ•ˆç‡

**æ ¸å¿ƒå†…å®¹**

**3.1 Predict - åŸºç¡€é¢„æµ‹ï¼ˆ2å°æ—¶ï¼‰**
```python
import dspy

# æœ€ç®€å•çš„é¢„æµ‹
class Sentiment(dspy.Signature):
    text = dspy.InputField()
    sentiment = dspy.OutputField(desc="æ­£é¢ã€è´Ÿé¢æˆ–ä¸­æ€§")

predictor = dspy.Predict(Sentiment)
result = predictor(text="è¿™ä¸ªäº§å“å¤ªæ£’äº†ï¼")
print(result.sentiment)  # è¾“å‡ºï¼šæ­£é¢
```

**3.2 ChainOfThought - æ€ç»´é“¾æ¨ç†ï¼ˆ3å°æ—¶ï¼‰**
```python
class MathProblem(dspy.Signature):
    """æ•°å­¦é—®é¢˜æ±‚è§£"""
    problem = dspy.InputField(desc="æ•°å­¦é—®é¢˜æè¿°")
    answer = dspy.OutputField(desc="æœ€ç»ˆç­”æ¡ˆ")

# ä½¿ç”¨æ€ç»´é“¾
cot = dspy.ChainOfThought(MathProblem)
result = cot(problem="å¦‚æœä¸€ä¸ªè‹¹æœ3å…ƒï¼Œä¹°5ä¸ªéœ€è¦å¤šå°‘é’±ï¼Ÿ")

print(f"æ¨ç†è¿‡ç¨‹ï¼š{result.reasoning}")
print(f"ç­”æ¡ˆï¼š{result.answer}")

# è¾“å‡ºç¤ºä¾‹ï¼š
# æ¨ç†è¿‡ç¨‹ï¼šé¦–å…ˆï¼Œä¸€ä¸ªè‹¹æœ3å…ƒã€‚ä¹°5ä¸ªè‹¹æœï¼Œéœ€è¦è®¡ç®—3 Ã— 5 = 15å…ƒ
# ç­”æ¡ˆï¼š15å…ƒ
```

**ChainOfThoughtçš„é«˜çº§ç”¨æ³•**
```python
class ComplexReasoning(dspy.Signature):
    context = dspy.InputField()
    question = dspy.InputField()
    answer = dspy.OutputField()

# é…ç½®æ¨ç†æ·±åº¦
cot_deep = dspy.ChainOfThought(
    ComplexReasoning,
    reasoning_depth=3  # æ›´æ·±å±‚æ¬¡çš„æ¨ç†
)

# å¤šæ­¥éª¤æ¨ç†
result = cot_deep(
    context="é‡å­è®¡ç®—åˆ©ç”¨é‡å­å åŠ å’Œçº ç¼ åŸç†...",
    question="é‡å­è®¡ç®—ç›¸æ¯”ç»å…¸è®¡ç®—çš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ"
)
```

**3.3 ReAct - æ¨ç†+è¡ŒåŠ¨æ™ºèƒ½ä½“ï¼ˆ3å°æ—¶ï¼‰**
```python
from dspy import Tool

# å®šä¹‰å·¥å…·
def search_wikipedia(query: str) -> str:
    """æœç´¢ç»´åŸºç™¾ç§‘"""
    # å®ç°æœç´¢é€»è¾‘
    return f"å…³äº{query}çš„ä¿¡æ¯..."

def calculate(expression: str) -> float:
    """è®¡ç®—æ•°å­¦è¡¨è¾¾å¼"""
    return eval(expression)

# åˆ›å»ºå·¥å…·åˆ—è¡¨
tools = [
    Tool(func=search_wikipedia, name="æœç´¢", desc="æœç´¢ç»´åŸºç™¾ç§‘è·å–ä¿¡æ¯"),
    Tool(func=calculate, name="è®¡ç®—å™¨", desc="è®¡ç®—æ•°å­¦è¡¨è¾¾å¼")
]

# ReActæ™ºèƒ½ä½“
class ReactAgent(dspy.Module):
    def __init__(self):
        super().__init__()
        self.react = dspy.ReAct(tools=tools)

    def forward(self, task):
        return self.react(task=task)

# ä½¿ç”¨æ™ºèƒ½ä½“
agent = ReactAgent()
result = agent(task="æŸ¥æ‰¾åŒ—äº¬çš„äººå£æ•°é‡å¹¶è®¡ç®—å…¶10%æ˜¯å¤šå°‘")
```

**3.4 ProgramOfThought - ç¨‹åºåŒ–æ€ç»´ï¼ˆ2å°æ—¶ï¼‰**
```python
class MathSolver(dspy.Signature):
    problem = dspy.InputField()
    solution = dspy.OutputField()

# ç¨‹åºåŒ–æ€ç»´ä¼šç”ŸæˆPythonä»£ç æ¥è§£å†³é—®é¢˜
pot = dspy.ProgramOfThought(MathSolver)
result = pot(problem="è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬20é¡¹")

print(f"ç”Ÿæˆçš„ä»£ç ï¼š\n{result.code}")
print(f"æ‰§è¡Œç»“æœï¼š{result.solution}")
```

**3.5 é«˜çº§é¢„æµ‹æ¨¡å—ï¼ˆ2å°æ—¶ï¼‰**

**BestOfN - å¤šæ¬¡é‡‡æ ·é€‰æœ€ä¼˜**
```python
best_of_n = dspy.BestOfN(
    predictor=dspy.ChainOfThought(MathProblem),
    n=5,  # ç”Ÿæˆ5ä¸ªå€™é€‰ç­”æ¡ˆ
    metric=lambda x, y: x.answer == y.answer  # é€‰æ‹©æ ‡å‡†
)
```

**MultiChainComparison - å¤šé“¾æ¯”è¾ƒ**
```python
mcc = dspy.MultiChainComparison(
    signature=ComplexReasoning,
    num_chains=3  # ç”Ÿæˆ3æ¡æ¨ç†é“¾å¹¶æ¯”è¾ƒ
)
```

**KNN - åŸºäºç›¸ä¼¼æ ·æœ¬çš„æ¨ç†**
```python
knn = dspy.KNN(
    k=3,  # ä½¿ç”¨3ä¸ªæœ€ç›¸ä¼¼çš„æ ·æœ¬
    trainset=train_examples
)
```

**Refine - è¿­ä»£æ”¹è¿›**
```python
refine = dspy.Refine(
    signature=QuestionAnswering,
    max_iterations=3  # æœ€å¤šè¿­ä»£3æ¬¡æ”¹è¿›ç­”æ¡ˆ
)
```

**å®è·µä»»åŠ¡**
- [ ] å®ç°å¹¶å¯¹æ¯”æ‰€æœ‰é¢„æµ‹æ¨¡å—
- [ ] åˆ›å»ºæ€§èƒ½å¯¹æ¯”æŠ¥å‘Š
- [ ] è®¾è®¡æ¨¡å—ç»„åˆæ–¹æ¡ˆ
- [ ] ä¼˜åŒ–æ¨ç†è´¨é‡å’Œé€Ÿåº¦
- [ ] å®ç°é”™è¯¯é‡è¯•æœºåˆ¶

**è¯„ä¼°æ ‡å‡†**
- æ­£ç¡®ä½¿ç”¨å„ç§æ¨¡å— âœ“
- ç†è§£é€‚ç”¨åœºæ™¯ âœ“
- æ€§èƒ½å¯¹æ¯”åˆ†æ âœ“
- ç»„åˆè®¾è®¡åˆç† âœ“

---

#### æ¨¡å—4ï¼šç®€å•ä»»åŠ¡å®æˆ˜ï¼ˆç¬¬3å‘¨ï¼Œ12å°æ—¶ï¼‰

**å­¦ä¹ ç›®æ ‡**
- ç»¼åˆè¿ç”¨å‰ä¸‰ä¸ªæ¨¡å—çš„çŸ¥è¯†
- å®Œæˆ3ä¸ªå®æˆ˜é¡¹ç›®
- å»ºç«‹å®Œæ•´çš„å¼€å‘æµç¨‹
- æŒæ¡è¯„ä¼°å’Œä¼˜åŒ–æ–¹æ³•

**é¡¹ç›®1ï¼šæ™ºèƒ½é—®ç­”ç³»ç»Ÿï¼ˆ4å°æ—¶ï¼‰**

**éœ€æ±‚åˆ†æ**
- æ”¯æŒå¤šè½®å¯¹è¯
- åŸºäºä¸Šä¸‹æ–‡çš„é—®ç­”
- ç­”æ¡ˆè´¨é‡è¯„ä¼°
- æ”¯æŒå¤šç§é—®é¢˜ç±»å‹

**ç³»ç»Ÿè®¾è®¡**
```python
import dspy
from typing import List, Optional

class ContextualQA(dspy.Module):
    """ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„é—®ç­”ç³»ç»Ÿ"""

    def __init__(self):
        super().__init__()

        # å®šä¹‰ç­¾å
        class QASignature(dspy.Signature):
            """åŸºäºä¸Šä¸‹æ–‡çš„é—®ç­”"""
            history = dspy.InputField(desc="å¯¹è¯å†å²")
            context = dspy.InputField(desc="ç›¸å…³æ–‡æ¡£")
            question = dspy.InputField(desc="å½“å‰é—®é¢˜")
            answer = dspy.OutputField(desc="å‡†ç¡®ç­”æ¡ˆ")
            confidence = dspy.OutputField(desc="ç½®ä¿¡åº¦")

        # ä½¿ç”¨æ€ç»´é“¾æ¨ç†
        self.qa_engine = dspy.ChainOfThought(QASignature)

        # å¯¹è¯å†å²ç®¡ç†
        self.conversation_history = []

    def forward(self, context: str, question: str) -> dspy.Prediction:
        # æ„å»ºå†å²è®°å½•
        history_text = "\n".join([
            f"Q: {h['question']}\nA: {h['answer']}"
            for h in self.conversation_history[-3:]  # ä¿ç•™æœ€è¿‘3è½®
        ])

        # æ‰§è¡Œé—®ç­”
        result = self.qa_engine(
            history=history_text,
            context=context,
            question=question
        )

        # æ›´æ–°å†å²
        self.conversation_history.append({
            "question": question,
            "answer": result.answer
        })

        return result

# ä½¿ç”¨ç¤ºä¾‹
qa_system = ContextualQA()

context = """
DSPyæ˜¯ä¸€ä¸ªç”¨äºç¼–ç¨‹è¯­è¨€æ¨¡å‹çš„æ¡†æ¶ã€‚å®ƒå…è®¸å¼€å‘è€…é€šè¿‡ç¼–å†™Pythonä»£ç 
è€Œä¸æ˜¯æ‰‹å·¥ç¼–å†™promptsæ¥æ„å»ºAIç³»ç»Ÿã€‚DSPyæä¾›äº†è‡ªåŠ¨ä¼˜åŒ–ç®—æ³•æ¥æ”¹è¿›ç³»ç»Ÿæ€§èƒ½ã€‚
"""

result1 = qa_system(context=context, question="DSPyæ˜¯ä»€ä¹ˆï¼Ÿ")
print(f"ç­”æ¡ˆ1ï¼š{result1.answer}")

result2 = qa_system(context=context, question="å®ƒçš„ä¸»è¦ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ")
print(f"ç­”æ¡ˆ2ï¼š{result2.answer}")
```

**é¡¹ç›®2ï¼šæ–‡æœ¬åˆ†ç±»å™¨ï¼ˆ4å°æ—¶ï¼‰**

**å¤šç±»åˆ«åˆ†ç±»å®ç°**
```python
from typing import List
from enum import Enum

class Category(str, Enum):
    TECHNOLOGY = "ç§‘æŠ€"
    BUSINESS = "å•†ä¸š"
    SPORTS = "ä½“è‚²"
    ENTERTAINMENT = "å¨±ä¹"
    POLITICS = "æ”¿æ²»"

class TextClassifier(dspy.Module):
    """å¤šç±»åˆ«æ–‡æœ¬åˆ†ç±»å™¨"""

    def __init__(self, categories: List[str]):
        super().__init__()

        class ClassificationSignature(dspy.Signature):
            text = dspy.InputField(desc="å¾…åˆ†ç±»æ–‡æœ¬")
            category = dspy.OutputField(desc=f"ç±»åˆ«ï¼Œå¯é€‰å€¼ï¼š{', '.join(categories)}")
            confidence = dspy.OutputField(desc="åˆ†ç±»ç½®ä¿¡åº¦")
            keywords = dspy.OutputField(desc="å…³é”®è¯åˆ—è¡¨")

        self.classifier = dspy.ChainOfThought(ClassificationSignature)
        self.categories = categories

    def forward(self, text: str):
        result = self.classifier(text=text)
        return result

# åˆ›å»ºåˆ†ç±»å™¨
categories = [c.value for c in Category]
classifier = TextClassifier(categories=categories)

# æµ‹è¯•
text = "è‹¹æœå…¬å¸å‘å¸ƒäº†æœ€æ–°çš„iPhoneï¼Œæ­è½½é©å‘½æ€§çš„A17èŠ¯ç‰‡"
result = classifier(text=text)
print(f"ç±»åˆ«ï¼š{result.category}")
print(f"ç½®ä¿¡åº¦ï¼š{result.confidence}")
print(f"å…³é”®è¯ï¼š{result.keywords}")
```

**æƒ…æ„Ÿåˆ†ææ‰©å±•**
```python
class SentimentAnalyzer(dspy.Module):
    """æƒ…æ„Ÿåˆ†æå™¨"""

    def __init__(self):
        super().__init__()

        class SentimentSignature(dspy.Signature):
            text = dspy.InputField()
            sentiment = dspy.OutputField(desc="æ­£é¢/è´Ÿé¢/ä¸­æ€§")
            intensity = dspy.OutputField(desc="æƒ…æ„Ÿå¼ºåº¦0-1")
            aspects = dspy.OutputField(desc="å…·ä½“æ–¹é¢çš„æƒ…æ„Ÿ")

        self.analyzer = dspy.ChainOfThought(SentimentSignature)

    def forward(self, text: str):
        return self.analyzer(text=text)
```

**é¡¹ç›®3ï¼šå†…å®¹ç”Ÿæˆå™¨ï¼ˆ4å°æ—¶ï¼‰**

**å¤šåœºæ™¯å†…å®¹ç”Ÿæˆ**
```python
class ContentGenerator(dspy.Module):
    """æ™ºèƒ½å†…å®¹ç”Ÿæˆå™¨"""

    def __init__(self):
        super().__init__()

        # ä¸åŒç±»å‹çš„ç”Ÿæˆå™¨
        self.generators = {
            "creative_writing": self._setup_creative_writer(),
            "technical_doc": self._setup_tech_writer(),
            "summary": self._setup_summarizer(),
        }

    def _setup_creative_writer(self):
        class CreativeWriting(dspy.Signature):
            topic = dspy.InputField()
            style = dspy.InputField(desc="å†™ä½œé£æ ¼")
            length = dspy.InputField(desc="ç›®æ ‡å­—æ•°")
            content = dspy.OutputField(desc="åˆ›ä½œå†…å®¹")

        return dspy.ChainOfThought(CreativeWriting)

    def _setup_tech_writer(self):
        class TechnicalDoc(dspy.Signature):
            feature = dspy.InputField(desc="åŠŸèƒ½æè¿°")
            audience = dspy.InputField(desc="ç›®æ ‡è¯»è€…")
            documentation = dspy.OutputField(desc="æŠ€æœ¯æ–‡æ¡£")
            examples = dspy.OutputField(desc="ä»£ç ç¤ºä¾‹")

        return dspy.ChainOfThought(TechnicalDoc)

    def _setup_summarizer(self):
        class Summarize(dspy.Signature):
            text = dspy.InputField()
            max_length = dspy.InputField()
            summary = dspy.OutputField()
            key_points = dspy.OutputField()

        return dspy.Predict(Summarize)

    def forward(self, content_type: str, **kwargs):
        generator = self.generators.get(content_type)
        if not generator:
            raise ValueError(f"ä¸æ”¯æŒçš„å†…å®¹ç±»å‹ï¼š{content_type}")

        return generator(**kwargs)

# ä½¿ç”¨ç¤ºä¾‹
generator = ContentGenerator()

# åˆ›æ„å†™ä½œ
creative = generator(
    content_type="creative_writing",
    topic="æœªæ¥åŸå¸‚",
    style="ç§‘å¹»",
    length="500å­—"
)

# æŠ€æœ¯æ–‡æ¡£
tech_doc = generator(
    content_type="technical_doc",
    feature="ç”¨æˆ·è®¤è¯ç³»ç»Ÿ",
    audience="åç«¯å¼€å‘è€…"
)

# æ–‡æœ¬æ‘˜è¦
summary = generator(
    content_type="summary",
    text="é•¿æ–‡æœ¬...",
    max_length="200å­—"
)
```

**å®è·µä»»åŠ¡**
- [ ] å®Œæˆ3ä¸ªé¡¹ç›®çš„å¼€å‘
- [ ] ç¼–å†™å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹
- [ ] å»ºç«‹æ€§èƒ½è¯„ä¼°ä½“ç³»
- [ ] æ’°å†™é¡¹ç›®æ–‡æ¡£
- [ ] è¿›è¡Œä»£ç å®¡æŸ¥å’Œä¼˜åŒ–

**è¯„ä¼°æ ‡å‡†**
- åŠŸèƒ½å®Œæ•´æ€§ï¼ˆ40åˆ†ï¼‰
- ä»£ç è´¨é‡ï¼ˆ30åˆ†ï¼‰
- æ–‡æ¡£å®Œå–„æ€§ï¼ˆ20åˆ†ï¼‰
- åˆ›æ–°æ€§ï¼ˆ10åˆ†ï¼‰

---

### ğŸš€ é˜¶æ®µäºŒï¼šè¿›é˜¶å¼€å‘ï¼ˆç¬¬4-6å‘¨ï¼‰

#### æ¨¡å—5ï¼šModuleç±»ä¸ç»„åˆè®¾è®¡ï¼ˆç¬¬4å‘¨ï¼Œ15å°æ—¶ï¼‰

**å­¦ä¹ ç›®æ ‡**
- æ·±å…¥ç†è§£ModuleåŸºç±»çš„è®¾è®¡ç†å¿µ
- æŒæ¡å¤æ‚æ¨¡å—çš„å¼€å‘æ–¹æ³•
- å­¦ä¼šç³»ç»Ÿæ¶æ„è®¾è®¡
- å®ç°é«˜åº¦å¯å¤ç”¨çš„ç»„ä»¶

**æ ¸å¿ƒå†…å®¹**

**5.1 ModuleåŸºç±»æ·±åº¦è§£æï¼ˆ5å°æ—¶ï¼‰**

**Moduleç”Ÿå‘½å‘¨æœŸ**
```python
import dspy
from typing import Any, Dict, List

class CustomModule(dspy.Module):
    """è‡ªå®šä¹‰æ¨¡å—å®Œæ•´ç¤ºä¾‹"""

    def __init__(self, config: Dict[str, Any]):
        """åˆå§‹åŒ–é˜¶æ®µ"""
        super().__init__()

        # 1. é…ç½®ç®¡ç†
        self.config = config

        # 2. å­æ¨¡å—åˆå§‹åŒ–
        self._setup_submodules()

        # 3. çŠ¶æ€åˆå§‹åŒ–
        self._setup_state()

        # 4. ç¼“å­˜åˆå§‹åŒ–
        self._setup_cache()

    def _setup_submodules(self):
        """è®¾ç½®å­æ¨¡å—"""
        # é¢„æµ‹æ¨¡å—
        self.predictor = dspy.ChainOfThought(MySignature)

        # æ£€ç´¢æ¨¡å—ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if self.config.get('use_retrieval'):
            self.retriever = dspy.Retrieve(k=5)

        # å…¶ä»–å­æ¨¡å—
        self.validator = ValidationModule()

    def _setup_state(self):
        """åˆå§‹åŒ–çŠ¶æ€"""
        self.call_count = 0
        self.error_count = 0
        self.cache_hits = 0

    def _setup_cache(self):
        """è®¾ç½®ç¼“å­˜"""
        from functools import lru_cache
        self.cache = {}

    def forward(self, **kwargs) -> dspy.Prediction:
        """å‰å‘ä¼ æ’­ - ä¸»è¦é€»è¾‘"""
        # 1. è¾“å…¥éªŒè¯
        validated_input = self._validate_input(**kwargs)

        # 2. ç¼“å­˜æ£€æŸ¥
        cache_key = self._get_cache_key(**validated_input)
        if cache_key in self.cache:
            self.cache_hits += 1
            return self.cache[cache_key]

        # 3. æ ¸å¿ƒå¤„ç†
        try:
            result = self._process(**validated_input)
            self.call_count += 1
        except Exception as e:
            self.error_count += 1
            result = self._handle_error(e, **validated_input)

        # 4. ç»“æœéªŒè¯å’Œç¼“å­˜
        validated_result = self._validate_output(result)
        self.cache[cache_key] = validated_result

        return validated_result

    def _validate_input(self, **kwargs):
        """è¾“å…¥éªŒè¯"""
        # å®ç°è¾“å…¥éªŒè¯é€»è¾‘
        return kwargs

    def _process(self, **kwargs):
        """æ ¸å¿ƒå¤„ç†é€»è¾‘"""
        # è°ƒç”¨å­æ¨¡å—
        result = self.predictor(**kwargs)
        return result

    def _validate_output(self, result):
        """è¾“å‡ºéªŒè¯"""
        # å®ç°è¾“å‡ºéªŒè¯é€»è¾‘
        return result

    def _handle_error(self, error, **kwargs):
        """é”™è¯¯å¤„ç†"""
        # å®ç°é”™è¯¯æ¢å¤é€»è¾‘
        return dspy.Prediction(error=str(error))

    def _get_cache_key(self, **kwargs):
        """ç”Ÿæˆç¼“å­˜é”®"""
        import hashlib
        import json
        key_str = json.dumps(kwargs, sort_keys=True)
        return hashlib.md5(key_str.encode()).hexdigest()

    def reset_stats(self):
        """é‡ç½®ç»Ÿè®¡ä¿¡æ¯"""
        self.call_count = 0
        self.error_count = 0
        self.cache_hits = 0

    def get_stats(self) -> Dict[str, int]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "call_count": self.call_count,
            "error_count": self.error_count,
            "cache_hits": self.cache_hits,
            "cache_size": len(self.cache)
        }
```

**5.2 é«˜çº§ç»„åˆæ¨¡å¼ï¼ˆ5å°æ—¶ï¼‰**

**ä¸²è”ç»„åˆï¼ˆPipelineï¼‰**
```python
class Pipeline(dspy.Module):
    """æ¨¡å—ä¸²è”ç»„åˆ"""

    def __init__(self, *modules):
        super().__init__()
        self.modules = modules

    def forward(self, **kwargs):
        result = kwargs
        for module in self.modules:
            result = module(**result)
        return result

# ä½¿ç”¨ç¤ºä¾‹
pipeline = Pipeline(
    QueryExpander(),      # æ­¥éª¤1ï¼šæŸ¥è¯¢æ‰©å±•
    DocumentRetriever(),  # æ­¥éª¤2ï¼šæ–‡æ¡£æ£€ç´¢
    AnswerGenerator()     # æ­¥éª¤3ï¼šç­”æ¡ˆç”Ÿæˆ
)
```

**å¹¶è”ç»„åˆï¼ˆEnsembleï¼‰**
```python
class Ensemble(dspy.Module):
    """æ¨¡å—å¹¶è”ç»„åˆ"""

    def __init__(self, *modules, aggregation="vote"):
        super().__init__()
        self.modules = modules
        self.aggregation = aggregation

    def forward(self, **kwargs):
        # å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰æ¨¡å—
        results = [module(**kwargs) for module in self.modules]

        # èšåˆç»“æœ
        if self.aggregation == "vote":
            return self._majority_vote(results)
        elif self.aggregation == "average":
            return self._average(results)
        else:
            return results

# ä½¿ç”¨ç¤ºä¾‹
ensemble = Ensemble(
    dspy.ChainOfThought(QA),
    dspy.ReAct(QA),
    dspy.ProgramOfThought(QA),
    aggregation="vote"
)
```

**æ¡ä»¶ç»„åˆï¼ˆRouterï¼‰**
```python
class Router(dspy.Module):
    """æ™ºèƒ½è·¯ç”±æ¨¡å—"""

    def __init__(self, routes: Dict[str, dspy.Module]):
        super().__init__()

        # è·¯ç”±åˆ¤æ–­å™¨
        class RouteDecision(dspy.Signature):
            query = dspy.InputField()
            available_routes = dspy.InputField()
            best_route = dspy.OutputField()
            confidence = dspy.OutputField()

        self.router = dspy.Predict(RouteDecision)
        self.routes = routes

    def forward(self, query: str, **kwargs):
        # å†³å®šè·¯ç”±
        route_names = list(self.routes.keys())
        decision = self.router(
            query=query,
            available_routes=", ".join(route_names)
        )

        # æ‰§è¡Œå¯¹åº”æ¨¡å—
        selected_module = self.routes[decision.best_route]
        return selected_module(query=query, **kwargs)

# ä½¿ç”¨ç¤ºä¾‹
router = Router({
    "factual": FactualQA(),
    "creative": CreativeQA(),
    "technical": TechnicalQA()
})
```

**é€’å½’ç»„åˆï¼ˆIterativeï¼‰**
```python
class IterativeRefiner(dspy.Module):
    """è¿­ä»£æ”¹è¿›æ¨¡å—"""

    def __init__(self, base_module, max_iterations=3):
        super().__init__()
        self.base_module = base_module
        self.max_iterations = max_iterations

        # è´¨é‡è¯„ä¼°å™¨
        class QualityCheck(dspy.Signature):
            output = dspy.InputField()
            is_satisfactory = dspy.OutputField(desc="æ˜¯æˆ–å¦")
            improvement_suggestions = dspy.OutputField()

        self.evaluator = dspy.Predict(QualityCheck)

    def forward(self, **kwargs):
        result = self.base_module(**kwargs)

        for iteration in range(self.max_iterations):
            # è¯„ä¼°è´¨é‡
            quality = self.evaluator(output=str(result))

            if quality.is_satisfactory.lower() == "æ˜¯":
                break

            # æ”¹è¿›
            kwargs['previous_output'] = str(result)
            kwargs['suggestions'] = quality.improvement_suggestions
            result = self.base_module(**kwargs)

        return result
```

**5.3 ç”Ÿäº§çº§RAGæ¨¡å—å®ç°ï¼ˆ5å°æ—¶ï¼‰**

å®Œæ•´çš„ç”Ÿäº§çº§RAGç³»ç»Ÿè®¾è®¡å°†åœ¨æ¨¡å—6è¯¦ç»†è®²è§£ã€‚

**å®è·µä»»åŠ¡**
- [ ] å®ç°å®Œæ•´çš„Moduleç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] å¼€å‘4ç§ç»„åˆæ¨¡å¼
- [ ] åˆ›å»ºå¯é…ç½®çš„æ¨¡å—å·¥å‚
- [ ] å®ç°æ¨¡å—æ€§èƒ½ç›‘æ§
- [ ] ç¼–å†™æ¨¡å—å•å…ƒæµ‹è¯•

**è¯„ä¼°æ ‡å‡†**
- æ¨¡å—è®¾è®¡åˆç†æ€§ âœ“
- ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§ âœ“
- æ€§èƒ½å’Œæ•ˆç‡ âœ“
- æ–‡æ¡£å®Œæ•´æ€§ âœ“

---

#### æ¨¡å—6ï¼šæ£€ç´¢å¢å¼ºç”Ÿæˆ(RAG)ï¼ˆç¬¬4-5å‘¨ï¼Œ15å°æ—¶ï¼‰

**å­¦ä¹ ç›®æ ‡**
- æŒæ¡RAGç³»ç»Ÿçš„å®Œæ•´æ¶æ„
- ç†è§£å„ç§æ£€ç´¢ç­–ç•¥
- å®ç°é«˜æ€§èƒ½RAGç³»ç»Ÿ
- ä¼˜åŒ–æ£€ç´¢å’Œç”Ÿæˆè´¨é‡

**æ ¸å¿ƒå†…å®¹**

**6.1 RAGç³»ç»Ÿæ¶æ„ï¼ˆ3å°æ—¶ï¼‰**

**åŸºç¡€RAGå®ç°**
```python
import dspy
from typing import List

class BasicRAG(dspy.Module):
    """åŸºç¡€RAGç³»ç»Ÿ"""

    def __init__(self, k=3):
        super().__init__()

        # æ£€ç´¢å™¨
        self.retrieve = dspy.Retrieve(k=k)

        # ç”Ÿæˆå™¨ç­¾å
        class GenerateAnswer(dspy.Signature):
            context = dspy.InputField(desc="æ£€ç´¢åˆ°çš„ç›¸å…³æ–‡æ¡£")
            question = dspy.InputField(desc="ç”¨æˆ·é—®é¢˜")
            answer = dspy.OutputField(desc="åŸºäºcontextçš„å‡†ç¡®ç­”æ¡ˆ")

        # ä½¿ç”¨æ€ç»´é“¾ç”Ÿæˆç­”æ¡ˆ
        self.generate = dspy.ChainOfThought(GenerateAnswer)

    def forward(self, question: str):
        # æ£€ç´¢ç›¸å…³æ–‡æ¡£
        context = self.retrieve(question).passages

        # ç”Ÿæˆç­”æ¡ˆ
        prediction = self.generate(context=context, question=question)

        return dspy.Prediction(
            context=context,
            answer=prediction.answer,
            reasoning=prediction.reasoning
        )

# é…ç½®æ£€ç´¢å™¨
import dspy
from dspy import ColBERTv2

# ä½¿ç”¨ColBERTæ£€ç´¢å™¨
colbert = ColBERTv2(url='http://localhost:8080/api/search')
dspy.settings.configure(rm=colbert)

# ä½¿ç”¨RAG
rag = BasicRAG(k=5)
result = rag(question="DSPyçš„ä¸»è¦ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ")
print(f"ç­”æ¡ˆï¼š{result.answer}")
print(f"æ¥æºï¼š{result.context}")
```

**6.2 é«˜çº§æ£€ç´¢ç­–ç•¥ï¼ˆ6å°æ—¶ï¼‰**

**å¤šè·³æ£€ç´¢ï¼ˆMulti-hop Retrievalï¼‰**
```python
class MultiHopRAG(dspy.Module):
    """å¤šè·³æ£€ç´¢RAGç³»ç»Ÿ"""

    def __init__(self, max_hops=2):
        super().__init__()
        self.max_hops = max_hops

        # æ£€ç´¢å™¨
        self.retrieve = dspy.Retrieve(k=3)

        # æŸ¥è¯¢ç”Ÿæˆå™¨
        class GenerateSearchQuery(dspy.Signature):
            context = dspy.InputField()
            question = dspy.InputField()
            next_query = dspy.OutputField(desc="ä¸‹ä¸€ä¸ªæœç´¢æŸ¥è¯¢")

        self.query_generator = dspy.ChainOfThought(GenerateSearchQuery)

        # ç­”æ¡ˆç”Ÿæˆå™¨
        class GenerateAnswer(dspy.Signature):
            contexts = dspy.InputField(desc="æ‰€æœ‰æ£€ç´¢åˆ°çš„æ–‡æ¡£")
            question = dspy.InputField()
            answer = dspy.OutputField()

        self.answer_generator = dspy.ChainOfThought(GenerateAnswer)

    def forward(self, question: str):
        all_contexts = []
        current_query = question

        # å¤šè·³æ£€ç´¢
        for hop in range(self.max_hops):
            # æ£€ç´¢å½“å‰æŸ¥è¯¢
            passages = self.retrieve(current_query).passages
            all_contexts.extend(passages)

            # ç”Ÿæˆä¸‹ä¸€ä¸ªæŸ¥è¯¢ï¼ˆé™¤äº†æœ€åä¸€è·³ï¼‰
            if hop < self.max_hops - 1:
                next_q = self.query_generator(
                    context="\n".join(passages),
                    question=question
                )
                current_query = next_q.next_query

        # åŸºäºæ‰€æœ‰ä¸Šä¸‹æ–‡ç”Ÿæˆç­”æ¡ˆ
        answer = self.answer_generator(
            contexts="\n\n".join(all_contexts),
            question=question
        )

        return dspy.Prediction(
            contexts=all_contexts,
            answer=answer.answer,
            hops=self.max_hops
        )
```

**æ··åˆæ£€ç´¢ï¼ˆHybrid Retrievalï¼‰**
```python
class HybridRAG(dspy.Module):
    """æ··åˆæ£€ç´¢ç­–ç•¥RAG"""

    def __init__(self):
        super().__init__()

        # ç¨ å¯†æ£€ç´¢ï¼ˆè¯­ä¹‰æœç´¢ï¼‰
        self.dense_retriever = dspy.Retrieve(k=10, mode='dense')

        # ç¨€ç–æ£€ç´¢ï¼ˆå…³é”®è¯æœç´¢ï¼‰
        self.sparse_retriever = dspy.Retrieve(k=10, mode='sparse')

        # é‡æ’åºå™¨
        class RerankPassages(dspy.Signature):
            query = dspy.InputField()
            passages = dspy.InputField()
            top_k = dspy.InputField()
            ranked_passages = dspy.OutputField(desc="é‡æ’åºåçš„æ–‡æ¡£åˆ—è¡¨")

        self.reranker = dspy.Predict(RerankPassages)

        # ç”Ÿæˆå™¨
        self.generator = dspy.ChainOfThought(GenerateAnswer)

    def forward(self, question: str, top_k=5):
        # å¹¶è¡Œæ£€ç´¢
        dense_results = self.dense_retriever(question).passages
        sparse_results = self.sparse_retriever(question).passages

        # åˆå¹¶ç»“æœï¼ˆå»é‡ï¼‰
        all_passages = list(set(dense_results + sparse_results))

        # é‡æ’åº
        reranked = self.reranker(
            query=question,
            passages="\n\n".join(all_passages),
            top_k=str(top_k)
        )

        # ç”Ÿæˆç­”æ¡ˆ
        answer = self.generator(
            context=reranked.ranked_passages,
            question=question
        )

        return answer
```

**æŸ¥è¯¢è·¯ç”±ï¼ˆQuery Routingï¼‰**
```python
class RoutedRAG(dspy.Module):
    """å¸¦æŸ¥è¯¢è·¯ç”±çš„RAGç³»ç»Ÿ"""

    def __init__(self):
        super().__init__()

        # æŸ¥è¯¢åˆ†ç±»å™¨
        class ClassifyQuery(dspy.Signature):
            query = dspy.InputField()
            category = dspy.OutputField(desc="factual/analytical/creative")
            complexity = dspy.OutputField(desc="simple/medium/complex")

        self.classifier = dspy.Predict(ClassifyQuery)

        # ä¸åŒç±»å‹çš„RAGæ¨¡å—
        self.rag_modules = {
            "factual_simple": BasicRAG(k=3),
            "factual_complex": MultiHopRAG(max_hops=2),
            "analytical": AnalyticalRAG(),
            "creative": CreativeRAG()
        }

    def forward(self, query: str):
        # åˆ†ç±»æŸ¥è¯¢
        classification = self.classifier(query=query)

        # é€‰æ‹©åˆé€‚çš„RAGæ¨¡å—
        module_key = f"{classification.category}_{classification.complexity}"
        selected_rag = self.rag_modules.get(
            module_key,
            self.rag_modules["factual_simple"]  # é»˜è®¤
        )

        # æ‰§è¡Œæ£€ç´¢å’Œç”Ÿæˆ
        return selected_rag(query=query)
```

**6.3 RAGç³»ç»Ÿä¼˜åŒ–ï¼ˆ6å°æ—¶ï¼‰**

**æ£€ç´¢è´¨é‡ä¼˜åŒ–**
```python
class OptimizedRAG(dspy.Module):
    """ä¼˜åŒ–çš„RAGç³»ç»Ÿ"""

    def __init__(self):
        super().__init__()

        # æŸ¥è¯¢å¢å¼º
        class EnhanceQuery(dspy.Signature):
            original_query = dspy.InputField()
            enhanced_query = dspy.OutputField()
            keywords = dspy.OutputField()

        self.query_enhancer = dspy.ChainOfThought(EnhanceQuery)

        # æ£€ç´¢
        self.retriever = dspy.Retrieve(k=10)

        # æ–‡æ¡£è¿‡æ»¤
        class FilterRelevance(dspy.Signature):
            query = dspy.InputField()
            document = dspy.InputField()
            is_relevant = dspy.OutputField(desc="yes/no")
            relevance_score = dspy.OutputField(desc="0-1")

        self.filter = dspy.Predict(FilterRelevance)

        # ä¸Šä¸‹æ–‡å‹ç¼©
        class CompressContext(dspy.Signature):
            documents = dspy.InputField()
            query = dspy.InputField()
            compressed = dspy.OutputField(desc="æœ€ç›¸å…³çš„ä¿¡æ¯æ‘˜è¦")

        self.compressor = dspy.ChainOfThought(CompressContext)

        # ç”Ÿæˆ
        self.generator = dspy.ChainOfThought(GenerateAnswer)

    def forward(self, question: str):
        # 1. æŸ¥è¯¢å¢å¼º
        enhanced = self.query_enhancer(original_query=question)

        # 2. æ£€ç´¢æ–‡æ¡£
        passages = self.retriever(enhanced.enhanced_query).passages

        # 3. è¿‡æ»¤ç›¸å…³æ–‡æ¡£
        relevant_docs = []
        for doc in passages:
            relevance = self.filter(query=question, document=doc)
            if relevance.is_relevant.lower() == "yes":
                relevant_docs.append((doc, float(relevance.relevance_score)))

        # æŒ‰ç›¸å…³æ€§æ’åº
        relevant_docs.sort(key=lambda x: x[1], reverse=True)
        top_docs = [doc for doc, _ in relevant_docs[:5]]

        # 4. ä¸Šä¸‹æ–‡å‹ç¼©
        compressed = self.compressor(
            documents="\n\n".join(top_docs),
            query=question
        )

        # 5. ç”Ÿæˆç­”æ¡ˆ
        answer = self.generator(
            context=compressed.compressed,
            question=question
        )

        return answer
```

**æ€§èƒ½ä¼˜åŒ–**
```python
class HighPerformanceRAG(dspy.Module):
    """é«˜æ€§èƒ½RAGç³»ç»Ÿ"""

    def __init__(self):
        super().__init__()

        # ç¼“å­˜
        from functools import lru_cache
        self.cache = {}

        # å¼‚æ­¥æ£€ç´¢
        import asyncio
        self.async_enabled = True

        # æ‰¹å¤„ç†
        self.batch_size = 32

        # æ¨¡å—
        self.retriever = dspy.Retrieve(k=5)
        self.generator = dspy.ChainOfThought(GenerateAnswer)

    @dspy.asyncify  # DSPyçš„å¼‚æ­¥è£…é¥°å™¨
    async def forward_async(self, question: str):
        # å¼‚æ­¥æ£€ç´¢
        passages = await self.retriever(question)

        # å¼‚æ­¥ç”Ÿæˆ
        answer = await self.generator(
            context=passages.passages,
            question=question
        )

        return answer

    def forward(self, question: str):
        # æ£€æŸ¥ç¼“å­˜
        cache_key = hash(question)
        if cache_key in self.cache:
            return self.cache[cache_key]

        # æ‰§è¡Œ
        if self.async_enabled:
            import asyncio
            result = asyncio.run(self.forward_async(question))
        else:
            passages = self.retriever(question).passages
            result = self.generator(context=passages, question=question)

        # ç¼“å­˜ç»“æœ
        self.cache[cache_key] = result
        return result
```

**å®è·µä»»åŠ¡**
- [ ] å®ç°åŸºç¡€RAGç³»ç»Ÿ
- [ ] å¼€å‘å¤šè·³æ£€ç´¢åŠŸèƒ½
- [ ] å®ç°æ··åˆæ£€ç´¢ç­–ç•¥
- [ ] æ·»åŠ æŸ¥è¯¢è·¯ç”±æœºåˆ¶
- [ ] ä¼˜åŒ–æ£€ç´¢å’Œç”Ÿæˆè´¨é‡
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

**è¯„ä¼°æ ‡å‡†**
- æ£€ç´¢å‡†ç¡®ç‡ âœ“
- ç­”æ¡ˆè´¨é‡ âœ“
- ç³»ç»Ÿæ€§èƒ½ âœ“
- ä»£ç è´¨é‡ âœ“

---

*[ç”±äºå†…å®¹è¿‡é•¿ï¼Œåç»­æ¨¡å—7-15çš„è¯¦ç»†å†…å®¹å°†ç»§ç»­...]*

## ğŸ“Š è¯„ä¼°ä½“ç³»

### å­¦ä¹ è¯„ä¼°æ–¹å¼
- **å¹³æ—¶ä½œä¸šï¼š** 35%ï¼ˆæ¯å‘¨ç»ƒä¹ é¢˜ï¼‰
- **é˜¶æ®µé¡¹ç›®ï¼š** 40%ï¼ˆ4ä¸ªé˜¶æ®µé¡¹ç›®ï¼‰
- **æœŸæœ«é¡¹ç›®ï¼š** 25%ï¼ˆæ¯•ä¸šè®¾è®¡ï¼‰

### è®¤è¯è¯ä¹¦
- **åŸºç¡€è¯ä¹¦ï¼š** å®Œæˆé˜¶æ®µä¸€å’ŒäºŒ
- **è¿›é˜¶è¯ä¹¦ï¼š** å®Œæˆé˜¶æ®µä¸€ã€äºŒã€ä¸‰
- **ä¸“å®¶è¯ä¹¦ï¼š** å®Œæˆå…¨éƒ¨å››ä¸ªé˜¶æ®µ
- **ä¼˜ç§€è¯ä¹¦ï¼š** æœŸæœ«é¡¹ç›®è¯„çº§A+

---

## ğŸ“ å­¦ä¹ èµ„æº

### å®˜æ–¹èµ„æº
- [DSPyå®˜æ–¹æ–‡æ¡£](https://dspy.ai/)
- [GitHubä»“åº“](https://github.com/stanfordnlp/dspy)
- [Discordç¤¾åŒº](https://discord.gg/dspy)

### æ‰©å±•é˜…è¯»
- DSPyè®ºæ–‡ç³»åˆ—
- LLMåº”ç”¨å¼€å‘æœ€ä½³å®è·µ
- Prompt EngineeringæŒ‡å—

---

**è¯¾ç¨‹ç‰ˆæƒï¼š** æœ¬è¯¾ç¨‹åŸºäºå¼€æºDSPyæ¡†æ¶ï¼Œéµå¾ªMITè®¸å¯è¯
**è”ç³»æ–¹å¼ï¼š** è¯¾ç¨‹ç¤¾åŒº + åœ¨çº¿ç­”ç–‘
